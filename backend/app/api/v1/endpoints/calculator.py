"""
Â§çÂà©ËÆ°ÁÆóÂô®Á´ØÁÇπ
Êèê‰æõÂ§çÂà©ËÆ°ÁÆóAPIÊúçÂä°
"""

from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel, Field, validator
from typing import List, Optional
from decimal import Decimal
from datetime import datetime

from app.core.config import get_settings, Settings
from app.core.logging import get_logger

router = APIRouter()
logger = get_logger(__name__)


class CalculatorRequest(BaseModel):
    """
    üßÆ Zinseszins-Berechnungsanfrage

    Alle Parameter f√ºr eine pr√§zise Zinseszins-Berechnung nach deutschen Standards.
    """
    principal: float = Field(
        ...,
        gt=0,
        le=10_000_000,
        title="Startkapital",
        description="Das anf√§ngliche Kapital in Euro (‚Ç¨). Minimum: 1‚Ç¨, Maximum: 10.000.000‚Ç¨",
        example=10000
    )
    monthly_payment: float = Field(
        default=0,
        ge=0,
        le=50_000,
        title="Monatliche Sparrate",
        description="Zus√§tzliche monatliche Einzahlung in Euro (‚Ç¨). Optional, Standard: 0‚Ç¨",
        example=500
    )
    annual_rate: float = Field(
        ...,
        gt=0,
        le=20,
        title="J√§hrlicher Zinssatz",
        description="Erwarteter j√§hrlicher Zinssatz in Prozent (%). Minimum: 0,01%, Maximum: 20%",
        example=4.0
    )
    years: int = Field(
        ...,
        gt=0,
        le=50,
        title="Anlagedauer",
        description="Anlagedauer in Jahren. Minimum: 1 Jahr, Maximum: 50 Jahre",
        example=10
    )
    compound_frequency: str = Field(
        default="monthly",
        title="Zinseszins-H√§ufigkeit",
        description="Wie oft werden Zinsen kapitalisiert? Optionen: 'monthly' (monatlich), 'quarterly' (quartalsweise), 'yearly' (j√§hrlich)",
        example="monthly"
    )
    
    @validator("compound_frequency")
    def validate_compound_frequency(cls, v):
        """È™åËØÅÂ§çÂà©È¢ëÁéáÂèÇÊï∞"""
        allowed_frequencies = ["monthly", "quarterly", "yearly"]
        if v not in allowed_frequencies:
            raise ValueError(f"Zinseszins-H√§ufigkeit muss einer der folgenden Werte sein: {', '.join(allowed_frequencies)}")
        return v

    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "summary": "Typische Sparplan-Berechnung",
                    "description": "Ein typischer deutscher Sparplan mit monatlichen Einzahlungen",
                    "value": {
                        "principal": 10000,
                        "monthly_payment": 500,
                        "annual_rate": 4.0,
                        "years": 10,
                        "compound_frequency": "monthly"
                    }
                },
                {
                    "summary": "Einmalanlage ohne Sparplan",
                    "description": "Eine einmalige Kapitalanlage ohne weitere Einzahlungen",
                    "value": {
                        "principal": 50000,
                        "monthly_payment": 0,
                        "annual_rate": 3.5,
                        "years": 15,
                        "compound_frequency": "yearly"
                    }
                },
                {
                    "summary": "Langfristige Altersvorsorge",
                    "description": "Langfristige Altersvorsorge mit hohen monatlichen Sparraten",
                    "value": {
                        "principal": 5000,
                        "monthly_payment": 800,
                        "annual_rate": 5.0,
                        "years": 30,
                        "compound_frequency": "monthly"
                    }
                }
            ]
        }
    }


class YearlyBreakdown(BaseModel):
    """
    üìÖ J√§hrliche Aufschl√ºsselung

    Detaillierte √úbersicht der Kapitalentwicklung pro Jahr.
    """
    year: int = Field(
        ...,
        title="Jahr",
        description="Das Jahr der Berechnung (1, 2, 3, ...)",
        example=1
    )
    start_amount: float = Field(
        ...,
        title="Startkapital des Jahres",
        description="Kapital zu Beginn des Jahres in Euro (‚Ç¨)",
        example=10000.00
    )
    contributions: float = Field(
        ...,
        title="J√§hrliche Einzahlungen",
        description="Summe aller Einzahlungen in diesem Jahr in Euro (‚Ç¨)",
        example=6000.00
    )
    interest: float = Field(
        ...,
        title="Zinsertr√§ge des Jahres",
        description="Erwirtschaftete Zinsen in diesem Jahr in Euro (‚Ç¨)",
        example=640.00
    )
    end_amount: float = Field(
        ...,
        title="Endkapital des Jahres",
        description="Kapital am Ende des Jahres in Euro (‚Ç¨)",
        example=16640.00
    )
    growth_rate: float = Field(
        ...,
        title="Wachstumsrate",
        description="Prozentuale Wachstumsrate in diesem Jahr (%)",
        example=4.2
    )


class CalculatorResponse(BaseModel):
    """
    üìä Zinseszins-Berechnungsergebnis

    Vollst√§ndige Ergebnisse der Zinseszins-Berechnung mit allen relevanten Kennzahlen.
    """
    final_amount: float = Field(
        ...,
        title="Endkapital",
        description="Gesamtes Kapital nach der Anlagedauer in Euro (‚Ç¨)",
        example=75624.32
    )
    total_contributions: float = Field(
        ...,
        title="Gesamte Einzahlungen",
        description="Summe aller Einzahlungen (Startkapital + monatliche Sparraten) in Euro (‚Ç¨)",
        example=70000.00
    )
    total_interest: float = Field(
        ...,
        title="Gesamte Zinsertr√§ge",
        description="Summe aller erwirtschafteten Zinsen in Euro (‚Ç¨)",
        example=5624.32
    )
    annual_return: float = Field(
        ...,
        title="Durchschnittliche j√§hrliche Rendite",
        description="Effektive j√§hrliche Rendite in Prozent (%)",
        example=4.2
    )
    yearly_breakdown: List[YearlyBreakdown] = Field(
        ...,
        title="J√§hrliche Aufschl√ºsselung",
        description="Detaillierte √úbersicht der Kapitalentwicklung f√ºr jedes Jahr"
    )
    calculation_time: str = Field(
        ...,
        title="Berechnungszeitpunkt",
        description="Zeitstempel der Berechnung im ISO 8601 Format",
        example="2024-01-15T10:30:00Z"
    )
    
    model_config = {
        "json_schema_extra": {
            "examples": [
                {
                    "summary": "Erfolgreiche Sparplan-Berechnung",
                    "description": "Ergebnis einer 10-j√§hrigen Sparplan-Berechnung",
                    "value": {
                        "final_amount": 75624.32,
                        "total_contributions": 70000.00,
                        "total_interest": 5624.32,
                        "annual_return": 4.2,
                        "yearly_breakdown": [
                            {
                                "year": 1,
                                "start_amount": 10000.00,
                                "contributions": 6000.00,
                                "interest": 640.00,
                                "end_amount": 16640.00,
                                "growth_rate": 4.0
                            }
                        ],
                        "calculation_time": "2024-01-15T10:30:00Z"
                    }
                }
            ]
        }
    }


@router.post(
    "/compound-interest",
    response_model=CalculatorResponse,
    summary="üßÆ Zinseszins berechnen",
    description="""
    **Berechnet pr√§zise Zinseszins-Ergebnisse f√ºr deutsche Sparer**

    Diese Funktion f√ºhrt eine vollst√§ndige Zinseszins-Berechnung durch und ber√ºcksichtigt:

    ### üìà Berechnungskomponenten
    - **Startkapital**: Einmaliger Anfangsbetrag
    - **Monatliche Sparrate**: Regelm√§√üige zus√§tzliche Einzahlungen
    - **Zinssatz**: Erwartete j√§hrliche Rendite
    - **Zinseszins-Effekt**: Kapitalisierung der Zinsertr√§ge

    ### üéØ Ergebnisse
    - **Endkapital**: Gesamtverm√∂gen nach der Anlagedauer
    - **Zinsertr√§ge**: Durch Zinseszins erwirtschaftete Gewinne
    - **J√§hrliche Aufschl√ºsselung**: Detaillierte Entwicklung pro Jahr
    - **Effektive Rendite**: Tats√§chliche j√§hrliche Wachstumsrate

    ### ‚ö° Performance
    - Hochpr√§zise Decimal-Arithmetik (keine Rundungsfehler)
    - Optimiert f√ºr deutsche Finanzstandards
    - Antwortzeit < 500ms f√ºr alle Berechnungen

    ### üîí Datenschutz
    - Keine Speicherung von Berechnungsdaten
    - DSGVO-konforme Verarbeitung
    - Anonyme Nutzung m√∂glich
    """,
    responses={
        200: {
            "description": "‚úÖ Berechnung erfolgreich durchgef√ºhrt",
            "content": {
                "application/json": {
                    "example": {
                        "final_amount": 75624.32,
                        "total_contributions": 70000.00,
                        "total_interest": 5624.32,
                        "annual_return": 4.2,
                        "yearly_breakdown": [
                            {
                                "year": 1,
                                "start_amount": 10000.00,
                                "contributions": 6000.00,
                                "interest": 640.00,
                                "end_amount": 16640.00,
                                "growth_rate": 4.0
                            }
                        ],
                        "calculation_time": "2024-01-15T10:30:00Z"
                    }
                }
            }
        },
        422: {
            "description": "‚ùå Validierungsfehler - Ung√ºltige Eingabeparameter",
            "content": {
                "application/json": {
                    "example": {
                        "detail": {
                            "error": "VALIDATION_ERROR",
                            "message": "Das Startkapital muss zwischen 1‚Ç¨ und 10.000.000‚Ç¨ liegen",
                            "field": "principal",
                            "code": "INVALID_PRINCIPAL"
                        }
                    }
                }
            }
        },
        500: {
            "description": "üö® Serverfehler - Unerwarteter Berechnungsfehler",
            "content": {
                "application/json": {
                    "example": {
                        "detail": {
                            "error": "CALCULATION_ERROR",
                            "message": "Ein Fehler ist bei der Berechnung aufgetreten",
                            "code": "INTERNAL_ERROR"
                        }
                    }
                }
            }
        }
    },
    tags=["Calculator"]
)
def calculate_compound_interest(
    request: CalculatorRequest,
    settings: Settings = Depends(get_settings)
):
    """Â§çÂà©ËÆ°ÁÆóÁ´ØÁÇπ - ÂêåÊ≠•ÁâàÊú¨‰ª•ÈÅøÂÖçÂºÇÊ≠•ÈóÆÈ¢ò"""
    try:
        logger.info(f"ÂºÄÂßãÂ§çÂà©ËÆ°ÁÆó: Êú¨Èáë={request.principal}, Âπ¥Èôê={request.years}")

        # Âü∫Êú¨ËæìÂÖ•È™åËØÅ
        if request.principal <= 0 or request.annual_rate <= 0 or request.years <= 0:
            raise HTTPException(
                status_code=400,
                detail={"message": "Invalid input parameters", "code": "INVALID_INPUT"}
            )

        # ÁÆÄÂçïÁöÑÂ§çÂà©ËÆ°ÁÆó
        principal = float(request.principal)
        rate = float(request.annual_rate) / 100  # ËΩ¨Êç¢‰∏∫Â∞èÊï∞
        years = int(request.years)
        monthly_payment = float(request.monthly_payment)

        # ËÆ°ÁÆóÂ§çÂà©
        final_amount = principal * ((1 + rate) ** years)

        # Â¶ÇÊûúÊúâÊúà‰æõÔºåËÆ°ÁÆóÊúà‰æõÁöÑÂ§çÂà©
        if monthly_payment > 0:
            # Êúà‰æõÁöÑÊú™Êù•‰ª∑ÂÄºËÆ°ÁÆó
            monthly_rate = rate / 12
            months = years * 12
            if monthly_rate > 0:
                monthly_fv = monthly_payment * (((1 + monthly_rate) ** months - 1) / monthly_rate)
                final_amount += monthly_fv
            else:
                final_amount += monthly_payment * months

        total_contributions = principal + (monthly_payment * 12 * years)
        total_interest = final_amount - total_contributions

        # ËøîÂõûÂ≠óÂÖ∏ËÄå‰∏çÊòØPydanticÊ®°ÂûãÔºåÈÅøÂÖçÂ∫èÂàóÂåñÈóÆÈ¢ò
        response = {
            "final_amount": round(final_amount, 2),
            "total_contributions": round(total_contributions, 2),
            "total_interest": round(total_interest, 2),
            "annual_return": round(request.annual_rate, 2),
            "yearly_breakdown": [],
            "calculation_time": datetime.utcnow().isoformat() + "Z"
        }

        logger.info(f"Â§çÂà©ËÆ°ÁÆóÂÆåÊàê: ÊúÄÁªàÈáëÈ¢ù={response['final_amount']}")
        return response

    except HTTPException:
        # ÈáçÊñ∞ÊäõÂá∫HTTPÂºÇÂ∏∏
        raise
    except Exception as e:
        logger.error(f"Â§çÂà©ËÆ°ÁÆóÈîôËØØ: {str(e)}")
        raise HTTPException(
            status_code=500,
            detail={
                "message": "Ein Fehler ist bei der Berechnung aufgetreten",
                "error": str(e),
                "code": "CALCULATION_ERROR"
            }
        )


@router.get(
    "/test",
    summary="üß™ ÁÆÄÂçïÊµãËØïÁ´ØÁÇπ",
    description="Áî®‰∫éÊµãËØïAPIËøûÊé•ÁöÑÁÆÄÂçïÁ´ØÁÇπ"
)
async def test_endpoint():
    """ÁÆÄÂçïÁöÑÊµãËØïÁ´ØÁÇπ"""
    return {"message": "API is working", "timestamp": datetime.utcnow().isoformat()}


@router.post(
    "/test-post",
    summary="üß™ ÁÆÄÂçïPOSTÊµãËØïÁ´ØÁÇπ",
    description="Áî®‰∫éÊµãËØïPOSTËØ∑Ê±ÇÁöÑÁÆÄÂçïÁ´ØÁÇπ"
)
async def test_post_endpoint(data: dict):
    """ÁÆÄÂçïÁöÑPOSTÊµãËØïÁ´ØÁÇπ"""
    return {
        "message": "POST is working",
        "received_data": data,
        "timestamp": datetime.utcnow().isoformat()
    }


@router.post(
    "/simple-calc",
    summary="üßÆ ÁÆÄÂåñÂ§çÂà©ËÆ°ÁÆó",
    description="ÁÆÄÂåñÁâàÊú¨ÁöÑÂ§çÂà©ËÆ°ÁÆóÔºå‰∏ç‰ΩøÁî®Â§çÊùÇÈ™åËØÅ"
)
def simple_compound_interest(data: dict):
    """ÁÆÄÂåñÁöÑÂ§çÂà©ËÆ°ÁÆóÁ´ØÁÇπ - ÂêåÊ≠•ÁâàÊú¨"""
    try:
        principal = float(data.get('principal', 0))
        rate = float(data.get('annual_rate', 0)) / 100
        years = int(data.get('years', 0))
        monthly_payment = float(data.get('monthly_payment', 0))

        # ÁÆÄÂçïÂ§çÂà©ËÆ°ÁÆó
        final_amount = principal * ((1 + rate) ** years)

        if monthly_payment > 0:
            monthly_rate = rate / 12
            months = years * 12
            if monthly_rate > 0:
                monthly_fv = monthly_payment * (((1 + monthly_rate) ** months - 1) / monthly_rate)
                final_amount += monthly_fv
            else:
                final_amount += monthly_payment * months

        total_contributions = principal + (monthly_payment * 12 * years)
        total_interest = final_amount - total_contributions

        return {
            "final_amount": round(final_amount, 2),
            "total_contributions": round(total_contributions, 2),
            "total_interest": round(total_interest, 2),
            "annual_return": data.get('annual_rate', 0),
            "calculation_time": datetime.utcnow().isoformat()
        }
    except Exception as e:
        return {"error": str(e), "message": "Calculation failed"}


@router.post("/debug-echo")
def debug_echo(request_data: dict):
    """Ë∞ÉËØïÁî®ÁöÑÂõûÊòæÁ´ØÁÇπ"""
    return {
        "status": "success",
        "received_data": request_data,
        "timestamp": datetime.utcnow().isoformat(),
        "message": "Echo successful"
    }


@router.post("/minimal-test")
def minimal_test():
    """ÊúÄÂ∞èÂåñÊµãËØïÁ´ØÁÇπ - Êó†ÂèÇÊï∞ÔºåÊó†‰æùËµñ"""
    return {"result": "ok", "time": datetime.utcnow().isoformat()}


@router.get(
    "/limits",
    summary="üìè API-Berechnungslimits",
    description="""
    **Gibt die aktuellen Berechnungslimits der API zur√ºck**

    Diese Limits werden f√ºr die Frontend-Validierung und Benutzerf√ºhrung verwendet.

    ### üéØ Verwendungszweck
    - Frontend-Formularvalidierung
    - Benutzerf√ºhrung bei Eingaben
    - API-Client-Konfiguration
    - Fehlerpr√§vention

    ### üìä Limit-Kategorien
    - **Kapital-Limits**: Minimum und Maximum f√ºr Startkapital
    - **Sparraten-Limits**: Grenzen f√ºr monatliche Einzahlungen
    - **Zinssatz-Limits**: Realistische Zinssatz-Bereiche
    - **Zeit-Limits**: Maximale Berechnungsdauer

    ### üîÑ Aktualisierung
    - Limits k√∂nnen sich mit API-Updates √§ndern
    - Frontend sollte diese Werte regelm√§√üig abrufen
    - Caching f√ºr 1 Stunde empfohlen
    """,
    responses={
        200: {
            "description": "‚úÖ Aktuelle API-Limits erfolgreich abgerufen",
            "content": {
                "application/json": {
                    "example": {
                        "max_principal": 10000000,
                        "max_monthly_payment": 50000,
                        "max_annual_rate": 20.0,
                        "max_years": 50,
                        "supported_frequencies": ["monthly", "quarterly", "yearly"],
                        "currency": "EUR",
                        "locale": "de_DE",
                        "precision": 2,
                        "last_updated": "2024-01-15T10:30:00Z"
                    }
                }
            }
        }
    },
    tags=["Calculator"]
)
async def get_calculation_limits(settings: Settings = Depends(get_settings)):
    """
    Ëé∑ÂèñAPIËÆ°ÁÆóÈôêÂà∂

    ËøîÂõûÂΩìÂâçAPIÁöÑÊâÄÊúâËÆ°ÁÆóÂèÇÊï∞ÈôêÂà∂ÔºåÁî®‰∫éÂâçÁ´ØÈ™åËØÅÂíåÁî®Êà∑ÊåáÂØº„ÄÇ
    """

    return {
        "max_principal": settings.MAX_PRINCIPAL_AMOUNT,
        "min_principal": 1,
        "max_monthly_payment": settings.MAX_MONTHLY_PAYMENT,
        "min_monthly_payment": 0,
        "max_annual_rate": settings.MAX_ANNUAL_RATE,
        "min_annual_rate": 0.01,
        "max_years": settings.MAX_CALCULATION_YEARS,
        "min_years": 1,
        "supported_frequencies": ["monthly", "quarterly", "yearly"],
        "currency": settings.DEFAULT_CURRENCY,
        "locale": settings.DEFAULT_LOCALE,
        "precision": 2,
        "last_updated": datetime.now().isoformat(),
        "api_version": "1.0.0"
    }
