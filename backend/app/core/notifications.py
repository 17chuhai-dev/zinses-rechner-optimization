"""
ÂëäË≠¶ÈÄöÁü•Á≥ªÁªü
ÂÆûÁé∞Â§öÊ∏†ÈÅìÂëäË≠¶ÈÄöÁü•ÂíåÂçáÁ∫ßÊú∫Âà∂
"""

import asyncio
import json
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass
import httpx
import logging

from app.core.config import settings

logger = logging.getLogger(__name__)


@dataclass
class NotificationConfig:
    """ÈÄöÁü•ÈÖçÁΩÆ"""
    
    # ÈÇÆ‰ª∂ÈÖçÁΩÆ
    SMTP_SERVER = "smtp.gmail.com"
    SMTP_PORT = 587
    SMTP_USERNAME = "alerts@zinses-rechner.de"
    SMTP_PASSWORD = ""  # ‰ªéÁéØÂ¢ÉÂèòÈáèËé∑Âèñ
    
    # SlackÈÖçÁΩÆ
    SLACK_WEBHOOK_URL = ""  # ‰ªéÁéØÂ¢ÉÂèòÈáèËé∑Âèñ
    SLACK_CHANNEL = "#alerts"
    
    # ÂëäË≠¶ÂçáÁ∫ßÈÖçÁΩÆ
    ESCALATION_RULES = {
        'warning': {'delay_minutes': 15, 'max_escalations': 2},
        'error': {'delay_minutes': 10, 'max_escalations': 3},
        'critical': {'delay_minutes': 5, 'max_escalations': 5}
    }
    
    # ÈÄöÁü•ÊäëÂà∂ÈÖçÁΩÆ
    SUPPRESSION_RULES = {
        'same_alert_minutes': 30,  # Áõ∏ÂêåÂëäË≠¶30ÂàÜÈíüÂÜÖ‰∏çÈáçÂ§çÂèëÈÄÅ
        'max_alerts_per_hour': 20,  # ÊØèÂ∞èÊó∂ÊúÄÂ§ö20‰∏™ÂëäË≠¶
        'quiet_hours': {'start': 22, 'end': 8}  # ÈùôÈªòÊó∂Èó¥
    }


class EmailNotifier:
    """ÈÇÆ‰ª∂ÈÄöÁü•Âô®"""
    
    def __init__(self, config: NotificationConfig):
        self.config = config
        self.sent_emails: List[Dict[str, Any]] = []
    
    async def send_alert_email(self, alert: Any, recipients: List[str]):
        """ÂèëÈÄÅÂëäË≠¶ÈÇÆ‰ª∂"""
        try:
            # ÂàõÂª∫ÈÇÆ‰ª∂ÂÜÖÂÆπ
            subject = f"üö® Zinses-Rechner Alert: {alert.name}"
            
            html_body = self._generate_email_html(alert)
            text_body = self._generate_email_text(alert)
            
            # ÂèëÈÄÅÈÇÆ‰ª∂
            await self._send_email(subject, html_body, text_body, recipients)
            
            # ËÆ∞ÂΩïÂèëÈÄÅÂéÜÂè≤
            self.sent_emails.append({
                'alert_id': alert.id,
                'recipients': recipients,
                'timestamp': datetime.now().isoformat(),
                'subject': subject
            })
            
            logger.info(f"Alert email sent: {alert.name} to {len(recipients)} recipients")
            
        except Exception as e:
            logger.error(f"Failed to send alert email: {e}")
    
    def _generate_email_html(self, alert: Any) -> str:
        """ÁîüÊàêHTMLÈÇÆ‰ª∂ÂÜÖÂÆπ"""
        severity_colors = {
            'info': '#3b82f6',
            'warning': '#f59e0b',
            'error': '#ef4444',
            'critical': '#dc2626'
        }
        
        color = severity_colors.get(alert.severity.value, '#6b7280')
        
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Zinses-Rechner Alert</title>
        </head>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="background: {color}; color: white; padding: 20px; border-radius: 8px 8px 0 0;">
                    <h1 style="margin: 0; font-size: 24px;">üö® System Alert</h1>
                    <p style="margin: 10px 0 0 0; opacity: 0.9;">Zinses-Rechner Monitoring System</p>
                </div>
                
                <div style="background: #f8f9fa; padding: 20px; border: 1px solid #e9ecef;">
                    <h2 style="color: {color}; margin-top: 0;">{alert.name}</h2>
                    <p><strong>Severity:</strong> {alert.severity.value.upper()}</p>
                    <p><strong>Message:</strong> {alert.message}</p>
                    <p><strong>Metric:</strong> {alert.metric_name}</p>
                    <p><strong>Current Value:</strong> {alert.current_value}</p>
                    <p><strong>Threshold:</strong> {alert.threshold}</p>
                    <p><strong>Timestamp:</strong> {alert.timestamp.strftime('%Y-%m-%d %H:%M:%S UTC')}</p>
                </div>
                
                <div style="background: white; padding: 20px; border: 1px solid #e9ecef; border-top: none; border-radius: 0 0 8px 8px;">
                    <h3>Recommended Actions:</h3>
                    <ul>
                        <li>Check system resources and performance</li>
                        <li>Review recent deployments or changes</li>
                        <li>Monitor for additional alerts</li>
                        <li>Contact on-call engineer if critical</li>
                    </ul>
                    
                    <p style="margin-top: 20px; font-size: 12px; color: #6b7280;">
                        This alert was generated by the Zinses-Rechner monitoring system.
                        <br>
                        Dashboard: <a href="https://zinses-rechner.de/admin/monitoring">View Monitoring Dashboard</a>
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
    
    def _generate_email_text(self, alert: Any) -> str:
        """ÁîüÊàêÁ∫ØÊñáÊú¨ÈÇÆ‰ª∂ÂÜÖÂÆπ"""
        return f"""
ZINSES-RECHNER SYSTEM ALERT

Alert: {alert.name}
Severity: {alert.severity.value.upper()}
Message: {alert.message}

Details:
- Metric: {alert.metric_name}
- Current Value: {alert.current_value}
- Threshold: {alert.threshold}
- Timestamp: {alert.timestamp.strftime('%Y-%m-%d %H:%M:%S UTC')}

Recommended Actions:
1. Check system resources and performance
2. Review recent deployments or changes
3. Monitor for additional alerts
4. Contact on-call engineer if critical

Dashboard: https://zinses-rechner.de/admin/monitoring

This alert was generated by the Zinses-Rechner monitoring system.
        """
    
    async def _send_email(self, subject: str, html_body: str, text_body: str, recipients: List[str]):
        """ÂèëÈÄÅÈÇÆ‰ª∂"""
        if not self.config.SMTP_PASSWORD:
            logger.warning("SMTP password not configured, skipping email notification")
            return
        
        try:
            # ÂàõÂª∫ÈÇÆ‰ª∂
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = self.config.SMTP_USERNAME
            msg['To'] = ', '.join(recipients)
            
            # Ê∑ªÂä†ÊñáÊú¨ÂíåHTMLÈÉ®ÂàÜ
            text_part = MIMEText(text_body, 'plain', 'utf-8')
            html_part = MIMEText(html_body, 'html', 'utf-8')
            
            msg.attach(text_part)
            msg.attach(html_part)
            
            # ÂèëÈÄÅÈÇÆ‰ª∂
            with smtplib.SMTP(self.config.SMTP_SERVER, self.config.SMTP_PORT) as server:
                server.starttls()
                server.login(self.config.SMTP_USERNAME, self.config.SMTP_PASSWORD)
                server.send_message(msg)
            
            logger.info(f"Email sent successfully to {recipients}")
            
        except Exception as e:
            logger.error(f"Failed to send email: {e}")
            raise


class SlackNotifier:
    """SlackÈÄöÁü•Âô®"""
    
    def __init__(self, config: NotificationConfig):
        self.config = config
        self.sent_messages: List[Dict[str, Any]] = []
    
    async def send_alert_slack(self, alert: Any):
        """ÂèëÈÄÅSlackÂëäË≠¶"""
        if not self.config.SLACK_WEBHOOK_URL:
            logger.warning("Slack webhook URL not configured, skipping Slack notification")
            return
        
        try:
            # ÁîüÊàêSlackÊ∂àÊÅØ
            message = self._generate_slack_message(alert)
            
            # ÂèëÈÄÅÂà∞Slack
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.config.SLACK_WEBHOOK_URL,
                    json=message,
                    timeout=10.0
                )
                
                if response.status_code == 200:
                    logger.info(f"Slack alert sent: {alert.name}")
                    
                    # ËÆ∞ÂΩïÂèëÈÄÅÂéÜÂè≤
                    self.sent_messages.append({
                        'alert_id': alert.id,
                        'timestamp': datetime.now().isoformat(),
                        'channel': self.config.SLACK_CHANNEL
                    })
                else:
                    logger.error(f"Slack notification failed: {response.status_code}")
                    
        except Exception as e:
            logger.error(f"Failed to send Slack notification: {e}")
    
    def _generate_slack_message(self, alert: Any) -> Dict[str, Any]:
        """ÁîüÊàêSlackÊ∂àÊÅØ"""
        severity_colors = {
            'info': '#3b82f6',
            'warning': '#f59e0b',
            'error': '#ef4444',
            'critical': '#dc2626'
        }
        
        severity_emojis = {
            'info': '‚ÑπÔ∏è',
            'warning': '‚ö†Ô∏è',
            'error': 'üö´',
            'critical': 'üö®'
        }
        
        color = severity_colors.get(alert.severity.value, '#6b7280')
        emoji = severity_emojis.get(alert.severity.value, 'üì¢')
        
        return {
            "channel": self.config.SLACK_CHANNEL,
            "username": "Zinses-Rechner Monitor",
            "icon_emoji": ":warning:",
            "attachments": [
                {
                    "color": color,
                    "title": f"{emoji} {alert.name}",
                    "text": alert.message,
                    "fields": [
                        {
                            "title": "Severity",
                            "value": alert.severity.value.upper(),
                            "short": True
                        },
                        {
                            "title": "Metric",
                            "value": alert.metric_name,
                            "short": True
                        },
                        {
                            "title": "Current Value",
                            "value": str(alert.current_value),
                            "short": True
                        },
                        {
                            "title": "Threshold",
                            "value": str(alert.threshold),
                            "short": True
                        }
                    ],
                    "footer": "Zinses-Rechner Monitoring",
                    "footer_icon": "https://zinses-rechner.de/favicon.ico",
                    "ts": int(alert.timestamp.timestamp())
                }
            ]
        }


class NotificationManager:
    """ÈÄöÁü•ÁÆ°ÁêÜÂô®"""
    
    def __init__(self):
        self.config = NotificationConfig()
        self.email_notifier = EmailNotifier(self.config)
        self.slack_notifier = SlackNotifier(self.config)
        self.notification_history: List[Dict[str, Any]] = []
        self.suppressed_alerts: Dict[str, datetime] = {}
    
    async def send_notification(self, alert: Any, channels: List[str]):
        """ÂèëÈÄÅÈÄöÁü•"""
        # Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•ÊäëÂà∂ÈÄöÁü•
        if self._should_suppress_notification(alert):
            logger.info(f"Notification suppressed for alert: {alert.name}")
            return
        
        # ËÆ∞ÂΩïÊäëÂà∂Êó∂Èó¥
        self.suppressed_alerts[alert.id] = datetime.now()
        
        # ÂèëÈÄÅÂà∞ÂêÑ‰∏™Ê∏†ÈÅì
        for channel in channels:
            try:
                if channel == "email":
                    await self._send_email_notification(alert)
                elif channel == "slack":
                    await self._send_slack_notification(alert)
                elif channel == "log":
                    self._send_log_notification(alert)
                else:
                    logger.warning(f"Unknown notification channel: {channel}")
                    
            except Exception as e:
                logger.error(f"Failed to send notification to {channel}: {e}")
        
        # ËÆ∞ÂΩïÈÄöÁü•ÂéÜÂè≤
        self.notification_history.append({
            'alert_id': alert.id,
            'alert_name': alert.name,
            'severity': alert.severity.value,
            'channels': channels,
            'timestamp': datetime.now().isoformat(),
            'success': True
        })
    
    def _should_suppress_notification(self, alert: Any) -> bool:
        """Ê£ÄÊü•ÊòØÂê¶Â∫îËØ•ÊäëÂà∂ÈÄöÁü•"""
        # Ê£ÄÊü•Áõ∏ÂêåÂëäË≠¶ÁöÑÊäëÂà∂Êó∂Èó¥
        if alert.id in self.suppressed_alerts:
            last_sent = self.suppressed_alerts[alert.id]
            suppression_period = timedelta(minutes=self.config.SUPPRESSION_RULES['same_alert_minutes'])
            
            if datetime.now() - last_sent < suppression_period:
                return True
        
        # Ê£ÄÊü•ÈùôÈªòÊó∂Èó¥
        current_hour = datetime.now().hour
        quiet_start = self.config.SUPPRESSION_RULES['quiet_hours']['start']
        quiet_end = self.config.SUPPRESSION_RULES['quiet_hours']['end']
        
        if quiet_start > quiet_end:  # Ë∑®ÂçàÂ§ú
            is_quiet_time = current_hour >= quiet_start or current_hour < quiet_end
        else:
            is_quiet_time = quiet_start <= current_hour < quiet_end
        
        # Âè™ÊúâÈùû‰∏•ÈáçÂëäË≠¶Âú®ÈùôÈªòÊó∂Èó¥Ë¢´ÊäëÂà∂
        if is_quiet_time and alert.severity.value not in ['error', 'critical']:
            return True
        
        # Ê£ÄÊü•ÊØèÂ∞èÊó∂ÂëäË≠¶Êï∞ÈáèÈôêÂà∂
        one_hour_ago = datetime.now() - timedelta(hours=1)
        recent_notifications = [
            notif for notif in self.notification_history
            if datetime.fromisoformat(notif['timestamp']) > one_hour_ago
        ]
        
        if len(recent_notifications) >= self.config.SUPPRESSION_RULES['max_alerts_per_hour']:
            return True
        
        return False
    
    async def _send_email_notification(self, alert: Any):
        """ÂèëÈÄÅÈÇÆ‰ª∂ÈÄöÁü•"""
        recipients = [
            "admin@zinses-rechner.de",
            "alerts@zinses-rechner.de"
        ]
        
        # Ê†πÊçÆ‰∏•ÈáçÁ®ãÂ∫¶Ê∑ªÂä†Êõ¥Â§öÊî∂‰ª∂‰∫∫
        if alert.severity.value in ['error', 'critical']:
            recipients.extend([
                "oncall@zinses-rechner.de",
                "devops@zinses-rechner.de"
            ])
        
        await self.email_notifier.send_alert_email(alert, recipients)
    
    async def _send_slack_notification(self, alert: Any):
        """ÂèëÈÄÅSlackÈÄöÁü•"""
        await self.slack_notifier.send_alert_slack(alert)
    
    def _send_log_notification(self, alert: Any):
        """ÂèëÈÄÅÊó•ÂøóÈÄöÁü•"""
        log_level = {
            'info': logging.INFO,
            'warning': logging.WARNING,
            'error': logging.ERROR,
            'critical': logging.CRITICAL
        }.get(alert.severity.value, logging.WARNING)
        
        logger.log(
            log_level,
            f"ALERT: {alert.name} - {alert.message} "
            f"(metric: {alert.metric_name}, value: {alert.current_value}, threshold: {alert.threshold})"
        )
    
    def get_notification_stats(self) -> Dict[str, Any]:
        """Ëé∑ÂèñÈÄöÁü•ÁªüËÆ°"""
        recent_notifications = [
            notif for notif in self.notification_history
            if datetime.fromisoformat(notif['timestamp']) > datetime.now() - timedelta(hours=24)
        ]
        
        return {
            'total_notifications_24h': len(recent_notifications),
            'notifications_by_severity': {
                severity: len([n for n in recent_notifications if n['severity'] == severity])
                for severity in ['info', 'warning', 'error', 'critical']
            },
            'notifications_by_channel': {
                'email': len([n for n in recent_notifications if 'email' in n['channels']]),
                'slack': len([n for n in recent_notifications if 'slack' in n['channels']]),
                'log': len([n for n in recent_notifications if 'log' in n['channels']])
            },
            'suppressed_alerts': len(self.suppressed_alerts),
            'last_notification': recent_notifications[-1]['timestamp'] if recent_notifications else None
        }


class EscalationManager:
    """ÂëäË≠¶ÂçáÁ∫ßÁÆ°ÁêÜÂô®"""
    
    def __init__(self, notification_manager: NotificationManager):
        self.notification_manager = notification_manager
        self.escalations: Dict[str, Dict[str, Any]] = {}
    
    async def handle_alert_escalation(self, alert: Any):
        """Â§ÑÁêÜÂëäË≠¶ÂçáÁ∫ß"""
        escalation_key = f"{alert.id}_{alert.severity.value}"
        
        if escalation_key not in self.escalations:
            # ÂàùÂßãÂåñÂçáÁ∫ßËÆ∞ÂΩï
            self.escalations[escalation_key] = {
                'alert_id': alert.id,
                'severity': alert.severity.value,
                'escalation_level': 0,
                'last_escalation': datetime.now(),
                'max_escalations': self.notification_manager.config.ESCALATION_RULES[alert.severity.value]['max_escalations']
            }
        
        escalation = self.escalations[escalation_key]
        escalation_rule = self.notification_manager.config.ESCALATION_RULES[alert.severity.value]
        
        # Ê£ÄÊü•ÊòØÂê¶ÈúÄË¶ÅÂçáÁ∫ß
        time_since_last = datetime.now() - escalation['last_escalation']
        delay_threshold = timedelta(minutes=escalation_rule['delay_minutes'])
        
        if time_since_last >= delay_threshold and escalation['escalation_level'] < escalation['max_escalations']:
            # ÊâßË°åÂçáÁ∫ß
            escalation['escalation_level'] += 1
            escalation['last_escalation'] = datetime.now()
            
            # ÂçáÁ∫ßÈÄöÁü•Ê∏†ÈÅì
            escalated_channels = self._get_escalated_channels(alert.severity.value, escalation['escalation_level'])
            
            logger.warning(
                f"Escalating alert: {alert.name} to level {escalation['escalation_level']} "
                f"with channels: {escalated_channels}"
            )
            
            # ÂèëÈÄÅÂçáÁ∫ßÈÄöÁü•
            await self.notification_manager.send_notification(alert, escalated_channels)
    
    def _get_escalated_channels(self, severity: str, level: int) -> List[str]:
        """Ëé∑ÂèñÂçáÁ∫ßÂêéÁöÑÈÄöÁü•Ê∏†ÈÅì"""
        base_channels = {
            'info': ['log'],
            'warning': ['log', 'email'],
            'error': ['log', 'email', 'slack'],
            'critical': ['log', 'email', 'slack']
        }
        
        channels = base_channels.get(severity, ['log'])
        
        # Ê†πÊçÆÂçáÁ∫ßÁ∫ßÂà´Ê∑ªÂä†Êõ¥Â§öÊ∏†ÈÅì
        if level >= 2:
            if 'sms' not in channels:
                channels.append('sms')  # ÂÅáËÆæÊúâSMSÈÄöÁü•
        
        if level >= 3:
            if 'phone' not in channels:
                channels.append('phone')  # ÂÅáËÆæÊúâÁîµËØùÈÄöÁü•
        
        return channels


# ÂÖ®Â±ÄÈÄöÁü•ÁÆ°ÁêÜÂô®ÂÆû‰æã
notification_manager = NotificationManager()
escalation_manager = EscalationManager(notification_manager)


def get_notification_manager() -> NotificationManager:
    """Ëé∑ÂèñÈÄöÁü•ÁÆ°ÁêÜÂô®ÂÆû‰æã"""
    return notification_manager


def get_escalation_manager() -> EscalationManager:
    """Ëé∑ÂèñÂçáÁ∫ßÁÆ°ÁêÜÂô®ÂÆû‰æã"""
    return escalation_manager
