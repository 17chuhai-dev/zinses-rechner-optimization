"""
å‘Šè­¦é€šçŸ¥ç³»ç»Ÿ
å®ç°å¤šæ¸ é“å‘Šè­¦é€šçŸ¥å’Œå‡çº§æœºåˆ¶
"""

import asyncio
import json
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from typing import Dict, List, Any, Optional
from datetime import datetime, timedelta
from dataclasses import dataclass
import httpx
import logging

from app.core.config import settings

logger = logging.getLogger(__name__)


@dataclass
class NotificationConfig:
    """é€šçŸ¥é…ç½®"""
    
    # é‚®ä»¶é…ç½®
    SMTP_SERVER = "smtp.gmail.com"
    SMTP_PORT = 587
    SMTP_USERNAME = "alerts@zinses-rechner.de"
    SMTP_PASSWORD = ""  # ä»ç¯å¢ƒå˜é‡è·å–
    
    # Slacké…ç½®
    SLACK_WEBHOOK_URL = ""  # ä»ç¯å¢ƒå˜é‡è·å–
    SLACK_CHANNEL = "#alerts"
    
    # å‘Šè­¦å‡çº§é…ç½®
    ESCALATION_RULES = {
        'warning': {'delay_minutes': 15, 'max_escalations': 2},
        'error': {'delay_minutes': 10, 'max_escalations': 3},
        'critical': {'delay_minutes': 5, 'max_escalations': 5}
    }
    
    # é€šçŸ¥æŠ‘åˆ¶é…ç½®
    SUPPRESSION_RULES = {
        'same_alert_minutes': 30,  # ç›¸åŒå‘Šè­¦30åˆ†é’Ÿå†…ä¸é‡å¤å‘é€
        'max_alerts_per_hour': 20,  # æ¯å°æ—¶æœ€å¤š20ä¸ªå‘Šè­¦
        'quiet_hours': {'start': 22, 'end': 8}  # é™é»˜æ—¶é—´
    }


class EmailNotifier:
    """é‚®ä»¶é€šçŸ¥å™¨"""
    
    def __init__(self, config: NotificationConfig):
        self.config = config
        self.sent_emails: List[Dict[str, Any]] = []
    
    async def send_alert_email(self, alert: Any, recipients: List[str]):
        """å‘é€å‘Šè­¦é‚®ä»¶"""
        try:
            # åˆ›å»ºé‚®ä»¶å†…å®¹
            subject = f"ğŸš¨ Zinses-Rechner Alert: {alert.name}"
            
            html_body = self._generate_email_html(alert)
            text_body = self._generate_email_text(alert)
            
            # å‘é€é‚®ä»¶
            await self._send_email(subject, html_body, text_body, recipients)
            
            # è®°å½•å‘é€å†å²
            self.sent_emails.append({
                'alert_id': alert.id,
                'recipients': recipients,
                'timestamp': datetime.now().isoformat(),
                'subject': subject
            })
            
            logger.info(f"Alert email sent: {alert.name} to {len(recipients)} recipients")
            
        except Exception as e:
            logger.error(f"Failed to send alert email: {e}")
    
    def _generate_email_html(self, alert: Any) -> str:
        """ç”ŸæˆHTMLé‚®ä»¶å†…å®¹"""
        severity_colors = {
            'info': '#3b82f6',
            'warning': '#f59e0b',
            'error': '#ef4444',
            'critical': '#dc2626'
        }
        
        color = severity_colors.get(alert.severity.value, '#6b7280')
        
        return f"""
        <!DOCTYPE html>
        <html>
        <head>
            <meta charset="utf-8">
            <title>Zinses-Rechner Alert</title>
        </head>
        <body style="font-family: Arial, sans-serif; line-height: 1.6; color: #333;">
            <div style="max-width: 600px; margin: 0 auto; padding: 20px;">
                <div style="background: {color}; color: white; padding: 20px; border-radius: 8px 8px 0 0;">
                    <h1 style="margin: 0; font-size: 24px;">ğŸš¨ System Alert</h1>
                    <p style="margin: 10px 0 0 0; opacity: 0.9;">Zinses-Rechner Monitoring System</p>
                </div>
                
                <div style="background: #f8f9fa; padding: 20px; border: 1px solid #e9ecef;">
                    <h2 style="color: {color}; margin-top: 0;">{alert.name}</h2>
                    <p><strong>Severity:</strong> {alert.severity.value.upper()}</p>
                    <p><strong>Message:</strong> {alert.message}</p>
                    <p><strong>Metric:</strong> {alert.metric_name}</p>
                    <p><strong>Current Value:</strong> {alert.current_value}</p>
                    <p><strong>Threshold:</strong> {alert.threshold}</p>
                    <p><strong>Timestamp:</strong> {alert.timestamp.strftime('%Y-%m-%d %H:%M:%S UTC')}</p>
                </div>
                
                <div style="background: white; padding: 20px; border: 1px solid #e9ecef; border-top: none; border-radius: 0 0 8px 8px;">
                    <h3>Recommended Actions:</h3>
                    <ul>
                        <li>Check system resources and performance</li>
                        <li>Review recent deployments or changes</li>
                        <li>Monitor for additional alerts</li>
                        <li>Contact on-call engineer if critical</li>
                    </ul>
                    
                    <p style="margin-top: 20px; font-size: 12px; color: #6b7280;">
                        This alert was generated by the Zinses-Rechner monitoring system.
                        <br>
                        Dashboard: <a href="https://zinses-rechner.de/admin/monitoring">View Monitoring Dashboard</a>
                    </p>
                </div>
            </div>
        </body>
        </html>
        """
    
    def _generate_email_text(self, alert: Any) -> str:
        """ç”Ÿæˆçº¯æ–‡æœ¬é‚®ä»¶å†…å®¹"""
        return f"""
ZINSES-RECHNER SYSTEM ALERT

Alert: {alert.name}
Severity: {alert.severity.value.upper()}
Message: {alert.message}

Details:
- Metric: {alert.metric_name}
- Current Value: {alert.current_value}
- Threshold: {alert.threshold}
- Timestamp: {alert.timestamp.strftime('%Y-%m-%d %H:%M:%S UTC')}

Recommended Actions:
1. Check system resources and performance
2. Review recent deployments or changes
3. Monitor for additional alerts
4. Contact on-call engineer if critical

Dashboard: https://zinses-rechner.de/admin/monitoring

This alert was generated by the Zinses-Rechner monitoring system.
        """
    
    async def _send_email(self, subject: str, html_body: str, text_body: str, recipients: List[str]):
        """å‘é€é‚®ä»¶"""
        if not self.config.SMTP_PASSWORD:
            logger.warning("SMTP password not configured, skipping email notification")
            return
        
        try:
            # åˆ›å»ºé‚®ä»¶
            msg = MIMEMultipart('alternative')
            msg['Subject'] = subject
            msg['From'] = self.config.SMTP_USERNAME
            msg['To'] = ', '.join(recipients)
            
            # æ·»åŠ æ–‡æœ¬å’ŒHTMLéƒ¨åˆ†
            text_part = MIMEText(text_body, 'plain', 'utf-8')
            html_part = MIMEText(html_body, 'html', 'utf-8')
            
            msg.attach(text_part)
            msg.attach(html_part)
            
            # å‘é€é‚®ä»¶
            with smtplib.SMTP(self.config.SMTP_SERVER, self.config.SMTP_PORT) as server:
                server.starttls()
                server.login(self.config.SMTP_USERNAME, self.config.SMTP_PASSWORD)
                server.send_message(msg)
            
            logger.info(f"Email sent successfully to {recipients}")
            
        except Exception as e:
            logger.error(f"Failed to send email: {e}")
            raise


class SlackNotifier:
    """Slacké€šçŸ¥å™¨"""
    
    def __init__(self, config: NotificationConfig):
        self.config = config
        self.sent_messages: List[Dict[str, Any]] = []
    
    async def send_alert_slack(self, alert: Any):
        """å‘é€Slackå‘Šè­¦"""
        if not self.config.SLACK_WEBHOOK_URL:
            logger.warning("Slack webhook URL not configured, skipping Slack notification")
            return
        
        try:
            # ç”ŸæˆSlackæ¶ˆæ¯
            message = self._generate_slack_message(alert)
            
            # å‘é€åˆ°Slack
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    self.config.SLACK_WEBHOOK_URL,
                    json=message,
                    timeout=10.0
                )
                
                if response.status_code == 200:
                    logger.info(f"Slack alert sent: {alert.name}")
                    
                    # è®°å½•å‘é€å†å²
                    self.sent_messages.append({
                        'alert_id': alert.id,
                        'timestamp': datetime.now().isoformat(),
                        'channel': self.config.SLACK_CHANNEL
                    })
                else:
                    logger.error(f"Slack notification failed: {response.status_code}")
                    
        except Exception as e:
            logger.error(f"Failed to send Slack notification: {e}")
    
    def _generate_slack_message(self, alert: Any) -> Dict[str, Any]:
        """ç”ŸæˆSlackæ¶ˆæ¯"""
        severity_colors = {
            'info': '#3b82f6',
            'warning': '#f59e0b',
            'error': '#ef4444',
            'critical': '#dc2626'
        }
        
        severity_emojis = {
            'info': 'â„¹ï¸',
            'warning': 'âš ï¸',
            'error': 'ğŸš«',
            'critical': 'ğŸš¨'
        }
        
        color = severity_colors.get(alert.severity.value, '#6b7280')
        emoji = severity_emojis.get(alert.severity.value, 'ğŸ“¢')
        
        return {
            "channel": self.config.SLACK_CHANNEL,
            "username": "Zinses-Rechner Monitor",
            "icon_emoji": ":warning:",
            "attachments": [
                {
                    "color": color,
                    "title": f"{emoji} {alert.name}",
                    "text": alert.message,
                    "fields": [
                        {
                            "title": "Severity",
                            "value": alert.severity.value.upper(),
                            "short": True
                        },
                        {
                            "title": "Metric",
                            "value": alert.metric_name,
                            "short": True
                        },
                        {
                            "title": "Current Value",
                            "value": str(alert.current_value),
                            "short": True
                        },
                        {
                            "title": "Threshold",
                            "value": str(alert.threshold),
                            "short": True
                        }
                    ],
                    "footer": "Zinses-Rechner Monitoring",
                    "footer_icon": "https://zinses-rechner.de/favicon.ico",
                    "ts": int(alert.timestamp.timestamp())
                }
            ]
        }


class NotificationManager:
    """é€šçŸ¥ç®¡ç†å™¨"""
    
    def __init__(self):
        self.config = NotificationConfig()
        self.email_notifier = EmailNotifier(self.config)
        self.slack_notifier = SlackNotifier(self.config)
        self.notification_history: List[Dict[str, Any]] = []
        self.suppressed_alerts: Dict[str, datetime] = {}
    
    async def send_notification(self, alert: Any, channels: List[str]):
        """å‘é€é€šçŸ¥"""
        # æ£€æŸ¥æ˜¯å¦åº”è¯¥æŠ‘åˆ¶é€šçŸ¥
        if self._should_suppress_notification(alert):
            logger.info(f"Notification suppressed for alert: {alert.name}")
            return
        
        # è®°å½•æŠ‘åˆ¶æ—¶é—´
        self.suppressed_alerts[alert.id] = datetime.now()
        
        # å‘é€åˆ°å„ä¸ªæ¸ é“
        for channel in channels:
            try:
                if channel == "email":
                    await self._send_email_notification(alert)
                elif channel == "slack":
                    await self._send_slack_notification(alert)
                elif channel == "log":
                    self._send_log_notification(alert)
                else:
                    logger.warning(f"Unknown notification channel: {channel}")
                    
            except Exception as e:
                logger.error(f"Failed to send notification to {channel}: {e}")
        
        # è®°å½•é€šçŸ¥å†å²
        self.notification_history.append({
            'alert_id': alert.id,
            'alert_name': alert.name,
            'severity': alert.severity.value,
            'channels': channels,
            'timestamp': datetime.now().isoformat(),
            'success': True
        })
    
    def _should_suppress_notification(self, alert: Any) -> bool:
        """æ£€æŸ¥æ˜¯å¦åº”è¯¥æŠ‘åˆ¶é€šçŸ¥"""
        # æ£€æŸ¥ç›¸åŒå‘Šè­¦çš„æŠ‘åˆ¶æ—¶é—´
        if alert.id in self.suppressed_alerts:
            last_sent = self.suppressed_alerts[alert.id]
            suppression_period = timedelta(minutes=self.config.SUPPRESSION_RULES['same_alert_minutes'])
            
            if datetime.now() - last_sent < suppression_period:
                return True
        
        # æ£€æŸ¥é™é»˜æ—¶é—´
        current_hour = datetime.now().hour
        quiet_start = self.config.SUPPRESSION_RULES['quiet_hours']['start']
        quiet_end = self.config.SUPPRESSION_RULES['quiet_hours']['end']
        
        if quiet_start > quiet_end:  # è·¨åˆå¤œ
            is_quiet_time = current_hour >= quiet_start or current_hour < quiet_end
        else:
            is_quiet_time = quiet_start <= current_hour < quiet_end
        
        # åªæœ‰éä¸¥é‡å‘Šè­¦åœ¨é™é»˜æ—¶é—´è¢«æŠ‘åˆ¶
        if is_quiet_time and alert.severity.value not in ['error', 'critical']:
            return True
        
        # æ£€æŸ¥æ¯å°æ—¶å‘Šè­¦æ•°é‡é™åˆ¶
        one_hour_ago = datetime.now() - timedelta(hours=1)
        recent_notifications = [
            notif for notif in self.notification_history
            if datetime.fromisoformat(notif['timestamp']) > one_hour_ago
        ]
        
        if len(recent_notifications) >= self.config.SUPPRESSION_RULES['max_alerts_per_hour']:
            return True
        
        return False
    
    async def _send_email_notification(self, alert: Any):
        """å‘é€é‚®ä»¶é€šçŸ¥"""
        recipients = [
            "admin@zinses-rechner.de",
            "alerts@zinses-rechner.de"
        ]
        
        # æ ¹æ®ä¸¥é‡ç¨‹åº¦æ·»åŠ æ›´å¤šæ”¶ä»¶äºº
        if alert.severity.value in ['error', 'critical']:
            recipients.extend([
                "oncall@zinses-rechner.de",
                "devops@zinses-rechner.de"
            ])
        
        await self.email_notifier.send_alert_email(alert, recipients)
    
    async def _send_slack_notification(self, alert: Any):
        """å‘é€Slacké€šçŸ¥"""
        await self.slack_notifier.send_alert_slack(alert)
    
    def _send_log_notification(self, alert: Any):
        """å‘é€æ—¥å¿—é€šçŸ¥"""
        log_level = {
            'info': logging.INFO,
            'warning': logging.WARNING,
            'error': logging.ERROR,
            'critical': logging.CRITICAL
        }.get(alert.severity.value, logging.WARNING)
        
        logger.log(
            log_level,
            f"ALERT: {alert.name} - {alert.message} "
            f"(metric: {alert.metric_name}, value: {alert.current_value}, threshold: {alert.threshold})"
        )
    
    def get_notification_stats(self) -> Dict[str, Any]:
        """è·å–é€šçŸ¥ç»Ÿè®¡"""
        recent_notifications = [
            notif for notif in self.notification_history
            if datetime.fromisoformat(notif['timestamp']) > datetime.now() - timedelta(hours=24)
        ]
        
        return {
            'total_notifications_24h': len(recent_notifications),
            'notifications_by_severity': {
                severity: len([n for n in recent_notifications if n['severity'] == severity])
                for severity in ['info', 'warning', 'error', 'critical']
            },
            'notifications_by_channel': {
                'email': len([n for n in recent_notifications if 'email' in n['channels']]),
                'slack': len([n for n in recent_notifications if 'slack' in n['channels']]),
                'log': len([n for n in recent_notifications if 'log' in n['channels']])
            },
            'suppressed_alerts': len(self.suppressed_alerts),
            'last_notification': recent_notifications[-1]['timestamp'] if recent_notifications else None
        }


class EscalationManager:
    """å‘Šè­¦å‡çº§ç®¡ç†å™¨"""
    
    def __init__(self, notification_manager: NotificationManager):
        self.notification_manager = notification_manager
        self.escalations: Dict[str, Dict[str, Any]] = {}
    
    async def handle_alert_escalation(self, alert: Any):
        """å¤„ç†å‘Šè­¦å‡çº§"""
        escalation_key = f"{alert.id}_{alert.severity.value}"
        
        if escalation_key not in self.escalations:
            # åˆå§‹åŒ–å‡çº§è®°å½•
            self.escalations[escalation_key] = {
                'alert_id': alert.id,
                'severity': alert.severity.value,
                'escalation_level': 0,
                'last_escalation': datetime.now(),
                'max_escalations': self.notification_manager.config.ESCALATION_RULES[alert.severity.value]['max_escalations']
            }
        
        escalation = self.escalations[escalation_key]
        escalation_rule = self.notification_manager.config.ESCALATION_RULES[alert.severity.value]
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦å‡çº§
        time_since_last = datetime.now() - escalation['last_escalation']
        delay_threshold = timedelta(minutes=escalation_rule['delay_minutes'])
        
        if time_since_last >= delay_threshold and escalation['escalation_level'] < escalation['max_escalations']:
            # æ‰§è¡Œå‡çº§
            escalation['escalation_level'] += 1
            escalation['last_escalation'] = datetime.now()
            
            # å‡çº§é€šçŸ¥æ¸ é“
            escalated_channels = self._get_escalated_channels(alert.severity.value, escalation['escalation_level'])
            
            logger.warning(
                f"Escalating alert: {alert.name} to level {escalation['escalation_level']} "
                f"with channels: {escalated_channels}"
            )
            
            # å‘é€å‡çº§é€šçŸ¥
            await self.notification_manager.send_notification(alert, escalated_channels)
    
    def _get_escalated_channels(self, severity: str, level: int) -> List[str]:
        """è·å–å‡çº§åçš„é€šçŸ¥æ¸ é“"""
        base_channels = {
            'info': ['log'],
            'warning': ['log', 'email'],
            'error': ['log', 'email', 'slack'],
            'critical': ['log', 'email', 'slack']
        }
        
        channels = base_channels.get(severity, ['log'])
        
        # æ ¹æ®å‡çº§çº§åˆ«æ·»åŠ æ›´å¤šæ¸ é“
        if level >= 2:
            if 'sms' not in channels:
                channels.append('sms')  # å‡è®¾æœ‰SMSé€šçŸ¥
        
        if level >= 3:
            if 'phone' not in channels:
                channels.append('phone')  # å‡è®¾æœ‰ç”µè¯é€šçŸ¥
        
        return channels


# å…¨å±€é€šçŸ¥ç®¡ç†å™¨å®ä¾‹
notification_manager = NotificationManager()
escalation_manager = EscalationManager(notification_manager)


def get_notification_manager() -> NotificationManager:
    """è·å–é€šçŸ¥ç®¡ç†å™¨å®ä¾‹"""
    return notification_manager


def get_escalation_manager() -> EscalationManager:
    """è·å–å‡çº§ç®¡ç†å™¨å®ä¾‹"""
    return escalation_manager
